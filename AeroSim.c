static char help[] = "Second Order TVD Finite Volume Example.\n";
/*F

We use a second order TVD finite volume method to evolve a system of PDEs. Our simple upwinded residual evaluation loops
over all mesh faces and uses a Riemann solver to produce the flux given the face geometry and cell values,
\begin{equation}
  f_i = \mathrm{riemann}(\mathrm{phys}, p_\mathrm{centroid}, \hat n, x^L, x^R)
\end{equation}
and then update the cell values given the cell volume.
\begin{eqnarray}
    f^L_i &-=& \frac{f_i}{vol^L} \\
    f^R_i &+=& \frac{f_i}{vol^R}
\end{eqnarray}

As an example, we can consider the shallow water wave equation,
\begin{eqnarray}
     h_t + \nabla\cdot \left( uh                              \right) &=& 0 \\
  (uh)_t + \nabla\cdot \left( u\otimes uh + \frac{g h^2}{2} I \right) &=& 0
\end{eqnarray}
where $h$ is wave height, $u$ is wave velocity, and $g$ is the acceleration due to gravity.

A representative Riemann solver for the shallow water equations is given in the PhysicsRiemann_SW() function,
\begin{eqnarray}
  f^{L,R}_h    &=& uh^{L,R} \cdot \hat n \\
  f^{L,R}_{uh} &=& \frac{f^{L,R}_h}{h^{L,R}} uh^{L,R} + g (h^{L,R})^2 \hat n \\
  c^{L,R}      &=& \sqrt{g h^{L,R}} \\
  s            &=& \max\left( \left|\frac{uh^L \cdot \hat n}{h^L}\right| + c^L, \left|\frac{uh^R \cdot \hat n}{h^R}\right| + c^R \right) \\
  f_i          &=& \frac{A_\mathrm{face}}{2} \left( f^L_i + f^R_i + s \left( x^L_i - x^R_i \right) \right)
\end{eqnarray}
where $c$ is the local gravity wave speed and $f_i$ is a Rusanov flux.

The more sophisticated residual evaluation in RHSFunctionLocal_LS() uses a least-squares fit to a quadratic polynomial
over a neighborhood of the given element.

The mesh is read in from an ExodusII file, usually generated by Cubit.
F*/

#include <petscts.h>
#include <petscfv.h>
#include <petscdmplex.h>
#include <petscsf.h>
#include <petscblaslapack.h>
#include <petsctime.h>

#include "AeroSim.h"

#undef __FUNCT__
#define __FUNCT__ "main"
int main(int argc, char **argv)
{
  MPI_Comm          comm;
  PetscMPIInt       rank;
  PetscErrorCode    ierr;
  User              user;
  PetscLogDouble       v1, v2;
  PetscInt          nplot = 0;
  char              fileName[2048];


  ierr = PetscInitialize(&argc, &argv, (char*) 0, help);CHKERRQ(ierr);
  comm = PETSC_COMM_WORLD;
  ierr = MPI_Comm_rank(comm, &rank);CHKERRQ(ierr);
  ierr = PetscNew(&user);CHKERRQ(ierr);
  ierr = PetscNew(&user->algebra);CHKERRQ(ierr);
  ierr = PetscNew(&user->model);CHKERRQ(ierr);
  ierr = PetscNew(&user->model->physics);CHKERRQ(ierr);

  Algebra   algebra = user->algebra;

  ierr = LoadOptions(comm, user);CHKERRQ(ierr);
  ierr = PetscTime(&v1);CHKERRQ(ierr);
  ierr = CreateMesh(comm, user);CHKERRQ(ierr);
  ierr = PetscTime(&v2);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD,
		       "Read and Distribute mesh takes %f sec \n", v2 - v1);CHKERRQ(ierr);
  ierr = SetUpLocalSpace(user);CHKERRQ(ierr); //Set up the dofs of each element
  ierr = ConstructGeometryFVM(&user->facegeom, &user->cellgeom, user);CHKERRQ(ierr);

  ierr = LimiterSetup(user);CHKERRQ(ierr);

  if (user->TimeIntegralMethod == EXPLICITMETHOD) { // explicit method
    if(user->myownexplicitmethod){// Using the fully explicit method based on my own routing
      ierr = PetscPrintf(PETSC_COMM_WORLD,"Using the fully explicit method based on my own routing\n");CHKERRQ(ierr);
      user->current_time = user->initial_time;
      user->current_step = 1;
      ierr = DMCreateGlobalVector(user->dm, &algebra->solution);CHKERRQ(ierr);
      ierr = PetscObjectSetName((PetscObject) algebra->solution, "solution");CHKERRQ(ierr);
      ierr = VecSet(algebra->solution, 0);CHKERRQ(ierr);
      ierr = SetInitialCondition(user->dm, algebra->solution, user);CHKERRQ(ierr);
      if(1){
        PetscViewer    viewer;
        ierr = OutputVTK(user->dm, "intialcondition.vtk", &viewer);CHKERRQ(ierr);
        ierr = VecView(algebra->solution, viewer);CHKERRQ(ierr);
        ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
        ierr = PetscPrintf(PETSC_COMM_WORLD,"Outputing the initial condition intialcondition.vtk!!! \n");CHKERRQ(ierr);
      }
      ierr = VecDuplicate(algebra->solution, &algebra->fn);CHKERRQ(ierr);
      ierr = VecDuplicate(algebra->solution, &algebra->oldsolution);CHKERRQ(ierr);
      if(user->Explicit_RK2||user->Explicit_RK4){
        ierr = PetscPrintf(PETSC_COMM_WORLD,"Use the second order Runge Kutta method \n");CHKERRQ(ierr);
      }else{
        ierr = PetscPrintf(PETSC_COMM_WORLD,"Use the first order forward Euler method \n");CHKERRQ(ierr);
      }
      nplot = 0; //the plot step
      while(user->current_time < (user->final_time - 0.05 * user->dt)){

        user->current_time = user->current_time + user->dt;
        ierr = FormTimeStepFunction(user, algebra, algebra->solution, algebra->fn);CHKERRQ(ierr);

        if(user->Explicit_RK2){
        /*
          U^n_1   = U^n + 0.5*dt*f(U^n)
          U^{n+1} = U^n + dt*f(U^n_1)
        */
          ierr = VecCopy(algebra->solution, algebra->oldsolution);CHKERRQ(ierr);
          //note that algebra->oldsolution and algebra->solution are both U^n
          ierr = VecAXPY(algebra->solution, 0.5*user->dt, algebra->fn);CHKERRQ(ierr);
          //U^n_1 = U^n + 0.5*dt*f(U^n), now algebra->solution is U^n_1, and algebra->fn is f(U^n)

          ierr = FormTimeStepFunction(user, algebra, algebra->solution, algebra->fn);CHKERRQ(ierr);
          //algebra->fn is f(U^n_1)

          // reset the algebra->solution to U^n
          ierr = VecCopy(algebra->oldsolution, algebra->solution);CHKERRQ(ierr);
          ierr = VecAXPY(algebra->solution, user->dt, algebra->fn);CHKERRQ(ierr);
          // now algebra->solution is U^{n+1} = U^n + dt*f(U^n_1)
        }else if(user->Explicit_RK4){
        /* refer to https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods
          k_1     = f(U^n)
          U^n_1   = U^n + 0.5*dt*k_1
          k_2     = f(U^n_1)
          U^n_2   = U^n + 0.5*dt*k_2
          k_3     = f(U^n_2)
          U^n_3   = U^n + 0.5*dt*k_3
          k_4     = f(U^n_3)

          U^{n+1} = U^n + dt/6*(k_1 + 2*k_2 + 2*k_3 + k_4)
        */
          Vec  VecTemp; // store the U^n_1
          Vec  k1, k2, k3, k4;

          ierr = VecDuplicate(algebra->solution, &k1);CHKERRQ(ierr);
          ierr = VecDuplicate(algebra->solution, &k2);CHKERRQ(ierr);
          ierr = VecDuplicate(algebra->solution, &k3);CHKERRQ(ierr);
          ierr = VecDuplicate(algebra->solution, &k4);CHKERRQ(ierr);
          ierr = VecCopy(algebra->solution, algebra->oldsolution);CHKERRQ(ierr);

          ierr = VecCopy(algebra->fn, k1);CHKERRQ(ierr);
          //note that algebra->oldsolution and algebra->solution are both U^n
          ierr = VecAXPY(algebra->solution, 0.5*user->dt, k1);CHKERRQ(ierr);
          //U^n_1 = U^n + 0.5*dt*k1, now algebra->solution is U^n_1, and algebra->fn is f(U^n)

          ierr = FormTimeStepFunction(user, algebra, algebra->solution, algebra->fn);CHKERRQ(ierr);
          //algebra->fn is f(U^n_1)
          ierr = VecCopy(algebra->fn, k2);CHKERRQ(ierr);
          // reset the algebra->solution to U^n
          ierr = VecCopy(algebra->oldsolution, algebra->solution);CHKERRQ(ierr);
          ierr = VecAXPY(algebra->solution, 0.5*user->dt, k2);CHKERRQ(ierr);
          //U^n_2 = U^n + 0.5*dt*k2, now algebra->solution is U^n_2, and algebra->fn is f(U^n_1)

          ierr = FormTimeStepFunction(user, algebra, algebra->solution, algebra->fn);CHKERRQ(ierr);
          //algebra->fn is f(U^n_2)
          ierr = VecCopy(algebra->fn, k3);CHKERRQ(ierr);
          // reset the algebra->solution to U^n
          ierr = VecCopy(algebra->oldsolution, algebra->solution);CHKERRQ(ierr);
          ierr = VecAXPY(algebra->solution, 0.5*user->dt, k3);CHKERRQ(ierr);
          //U^n_3 = U^n + 0.5*dt*k3, now algebra->solution is U^n_3, and algebra->fn is f(U^n_2)

          ierr = FormTimeStepFunction(user, algebra, algebra->solution, algebra->fn);CHKERRQ(ierr);
          //algebra->fn is f(U^n_3)
          ierr = VecCopy(algebra->fn, k4);CHKERRQ(ierr);

          //U^{n+1} = U^n + dt/6*(k_1 + 2*k_2 + 2*k_3 + k_4)
          PetscReal temp;
          temp = user->dt/6;
          // reset the algebra->solution to U^n
          ierr = VecCopy(algebra->oldsolution, algebra->solution);CHKERRQ(ierr);
          ierr = VecAXPY(algebra->solution, temp, k1);CHKERRQ(ierr);
          // now algebra->solution is U^n + dt/6*k_1
          ierr = VecAXPY(algebra->solution, 2*temp, k2);CHKERRQ(ierr);
          // now algebra->solution is U^n + dt/6*k_1 + 2*dt/6*k_2
          ierr = VecAXPY(algebra->solution, 2*temp, k3);CHKERRQ(ierr);
          // now algebra->solution is U^n + dt/6*k_1 + 2*dt/6*k_2 + 2*dt/6*k_3
          ierr = VecAXPY(algebra->solution, temp, k4);CHKERRQ(ierr);
          // now algebra->solution is U^n + dt/6*k_1 + 2*dt/6*k_2 + 2*dt/6*k_3 + dt/6*k_4

          ierr = VecDestroy(&k1);CHKERRQ(ierr);
          ierr = VecDestroy(&k2);CHKERRQ(ierr);
          ierr = VecDestroy(&k3);CHKERRQ(ierr);
          ierr = VecDestroy(&k4);CHKERRQ(ierr);
        }else{
          ierr = VecCopy(algebra->solution, algebra->oldsolution);CHKERRQ(ierr);
          ierr = VecAXPY(algebra->solution, user->dt, algebra->fn);CHKERRQ(ierr);
        }

        {// Monitor the solution and function norms
          PetscReal         norm;
          PetscLogDouble    space =0;
          PetscInt          size;

          PetscReal fnnorm;
          ierr = VecNorm(algebra->fn,NORM_2,&fnnorm);CHKERRQ(ierr);
          //ierr = VecView(algebra->fn, PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
          if(0){
            PetscViewer    viewer;
            ierr = OutputVTK(user->dm, "function.vtk", &viewer);CHKERRQ(ierr);
            ierr = VecView(algebra->fn, viewer);CHKERRQ(ierr);
            ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
            ierr = PetscPrintf(PETSC_COMM_WORLD,"Step %D at time %g with founction norm = %g \n",
                                user->current_step, user->current_time, fnnorm);CHKERRQ(ierr);
            //break;
          }

          ierr = VecNorm(algebra->solution,NORM_2,&norm);CHKERRQ(ierr);
          ierr = VecGetSize(algebra->solution, &size);CHKERRQ(ierr);
          norm   = norm/size;
          fnnorm = fnnorm/size;
          if (norm>1.e5) {
            SETERRQ2(PETSC_COMM_WORLD, PETSC_ERR_LIB,
            "The norm of the solution is: %f (current time: %f). The explicit method is going to DIVERGE!!!", norm, user->current_time);
          }
          if (user->current_step%10==0) {
            ierr = PetscPrintf(PETSC_COMM_WORLD,"Step %D at time %g with solution norm = %g and founction norm = %g \n",
                                user->current_step, user->current_time, norm, fnnorm);CHKERRQ(ierr);
          }
//          ierr =  PetscMallocGetCurrentUsage(&space);CHKERRQ(ierr);
//          if (user->current_step%10==0) {
//            ierr =  PetscPrintf(PETSC_COMM_WORLD,"Current space PetscMalloc()ed %g M\n",
//                                 space/(1024*1024));CHKERRQ(ierr);
//          }
        }

        { // Monitor the difference of two steps' solution
          PetscReal         norm;
          ierr = VecAXPY(algebra->oldsolution, -1, algebra->solution);CHKERRQ(ierr);
          ierr = VecNorm(algebra->oldsolution,NORM_2,&norm);CHKERRQ(ierr);
          if (user->current_step%10==0) {
            ierr = PetscPrintf(PETSC_COMM_WORLD,"Step %D at time %g with ||u_k-u_{k-1}|| = %g \n",
                              user->current_step, user->current_time, norm);CHKERRQ(ierr);
          }
          if((norm<1.e-6)||(user->current_step > user->max_time_its)) break;
        }

        // output the solution
        if (user->output_solution && (user->current_step%user->steps_output==0)){
          PetscViewer    viewer;

          nplot = user->current_step/user->steps_output;
          // update file name for the current time step
          ierr = PetscSNPrintf(fileName, sizeof(fileName),"%s_%d.vtk",user->solutionfile, nplot);CHKERRQ(ierr);
          ierr = PetscPrintf(PETSC_COMM_WORLD,"Outputing solution %s (current time %f)\n", fileName, user->current_time);CHKERRQ(ierr);
          ierr = OutputVTK(user->dm, fileName, &viewer);CHKERRQ(ierr);
          ierr = VecView(algebra->solution, viewer);CHKERRQ(ierr);
          ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
        }

        user->current_step++;

      }

      ierr = VecDestroy(&algebra->fn);CHKERRQ(ierr);
    }else{ // Using the fully explicit method based on the PETSC TS routing
      PetscReal         ftime;
      TS                ts;
      TSConvergedReason reason;
      PetscInt          nsteps;

      ierr = PetscPrintf(PETSC_COMM_WORLD,"Using the fully explicit method based on the PETSC TS routing\n");CHKERRQ(ierr);
      ierr = DMCreateGlobalVector(user->dm, &algebra->solution);CHKERRQ(ierr);
      ierr = PetscObjectSetName((PetscObject) algebra->solution, "solution");CHKERRQ(ierr);
      ierr = VecSet(algebra->solution, 0.0);CHKERRQ(ierr);
      ierr = SetInitialCondition(user->dm, algebra->solution, user);CHKERRQ(ierr);
      ierr = TSCreate(comm, &ts);CHKERRQ(ierr);
      ierr = TSSetType(ts, TSEULER);CHKERRQ(ierr);
      ierr = TSSetDM(ts, user->dm);CHKERRQ(ierr);
      ierr = TSMonitorSet(ts,TSMonitorFunctionError,(void*)user,NULL);CHKERRQ(ierr);
      ierr = TSSetRHSFunction(ts, NULL, MyRHSFunction, user);CHKERRQ(ierr);
      ierr = TSSetDuration(ts, 1000, user->final_time);CHKERRQ(ierr);
      ierr = TSSetInitialTimeStep(ts, user->initial_time, user->dt);CHKERRQ(ierr);
      ierr = TSSetFromOptions(ts);CHKERRQ(ierr);
      ierr = TSSolve(ts, algebra->solution);CHKERRQ(ierr);
      ierr = TSGetSolveTime(ts, &ftime);CHKERRQ(ierr);
      ierr = TSGetTimeStepNumber(ts, &nsteps);CHKERRQ(ierr);
      ierr = TSGetConvergedReason(ts, &reason);CHKERRQ(ierr);
      ierr = PetscPrintf(PETSC_COMM_WORLD,"%s at time %g after %D steps\n",TSConvergedReasons[reason],ftime,nsteps);CHKERRQ(ierr);
      ierr = TSDestroy(&ts);CHKERRQ(ierr);

    }

    if(user->benchmark_couette) {
      ierr = DMCreateGlobalVector(user->dm, &algebra->exactsolution);CHKERRQ(ierr);
      ierr = ComputeExactSolution(user->dm, user->final_time, algebra->exactsolution, user);CHKERRQ(ierr);
    }

    if(user->benchmark_couette) {
      PetscViewer    viewer;
      PetscReal      norm;

      ierr = OutputVTK(user->dm, "exact_solution.vtk", &viewer);CHKERRQ(ierr);
      ierr = VecView(algebra->exactsolution, viewer);CHKERRQ(ierr);
      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);

      ierr = VecAXPY(algebra->exactsolution, -1, algebra->solution);CHKERRQ(ierr);
      ierr = VecNorm(algebra->exactsolution,NORM_INFINITY,&norm);CHKERRQ(ierr);
      ierr = PetscPrintf(PETSC_COMM_WORLD,"Final time at %f, Error: ||u_k-u|| = %g \n", user->final_time, norm);CHKERRQ(ierr);

      ierr = OutputVTK(user->dm, "Error.vtk", &viewer);CHKERRQ(ierr);
      ierr = VecView(algebra->exactsolution, viewer);CHKERRQ(ierr);
      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
    }

    ierr = VecDestroy(&algebra->solution);CHKERRQ(ierr);
    if(user->myownexplicitmethod){ierr = VecDestroy(&algebra->oldsolution);CHKERRQ(ierr);}
    ierr = VecDestroy(&algebra->exactsolution);CHKERRQ(ierr);
    ierr = DMDestroy(&user->dm);CHKERRQ(ierr);
  } else if (user->TimeIntegralMethod == IMPLICITMETHOD) { // Using the fully implicit method
    ierr = PetscPrintf(PETSC_COMM_WORLD,"Using the fully implicit method\n");CHKERRQ(ierr);
    ierr =  SNESCreate(comm,&user->snes);CHKERRQ(ierr);
    ierr =  SNESSetDM(user->snes,user->dm);CHKERRQ(ierr);

    ierr = DMCreateGlobalVector(user->dm, &algebra->solution);CHKERRQ(ierr);
    ierr = VecDuplicate(algebra->solution, &algebra->oldsolution);CHKERRQ(ierr);
    ierr = VecDuplicate(algebra->solution, &algebra->f);CHKERRQ(ierr);
    ierr = VecDuplicate(algebra->solution, &algebra->fn);CHKERRQ(ierr);
    ierr = VecDuplicate(algebra->solution, &algebra->oldfn);CHKERRQ(ierr);

    ierr = PetscObjectSetName((PetscObject) algebra->solution, "solution");CHKERRQ(ierr);
    ierr = SetInitialCondition(user->dm, algebra->solution, user);CHKERRQ(ierr);

    ierr = DMSetMatType(user->dm, MATAIJ);CHKERRQ(ierr);
//    ierr = DMCreateMatrix(user->dm, &algebra->A);CHKERRQ(ierr);
    ierr = DMCreateMatrix(user->dm, &algebra->J);CHKERRQ(ierr);
    if (user->JdiffP) {
     /*Set up the preconditioner matrix*/
     ierr = DMCreateMatrix(user->dm, &algebra->P);CHKERRQ(ierr);
    }else{
     algebra->P = algebra->J;
    }

    ierr = MatSetOption(algebra->J, MAT_NEW_NONZERO_ALLOCATION_ERR, PETSC_FALSE);CHKERRQ(ierr);

    /*set nonlinear function */
    ierr =  SNESSetFunction(user->snes, algebra->f, FormFunction, (void*)user);CHKERRQ(ierr);
    /* compute Jacobian */
    ierr =  SNESSetJacobian(user->snes, algebra->J, algebra->P, FormJacobian, (void*)user);CHKERRQ(ierr);

    ierr = SNESSetFromOptions(user->snes);CHKERRQ(ierr);

    /* do the solve */
    if (user->timestep == TIMESTEP_STEADY_STATE) {
      ierr = SolveSteadyState(user);CHKERRQ(ierr);
    } else {
      ierr = SolveTimeDependent(user);CHKERRQ(ierr);
    }

    if (user->output_solution){
      PetscViewer    viewer;
      ierr = OutputVTK(user->dm, "solution.vtk", &viewer);CHKERRQ(ierr);
      ierr = VecView(algebra->solution, viewer);CHKERRQ(ierr);
      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
    }

    if(user->benchmark_couette) {
      PetscViewer    viewer;
      PetscReal      norm;

      ierr = OutputVTK(user->dm, "exact_solution.vtk", &viewer);CHKERRQ(ierr);
      ierr = VecView(algebra->exactsolution, viewer);CHKERRQ(ierr);
      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);

      ierr = VecAXPY(algebra->exactsolution, -1, algebra->solution);CHKERRQ(ierr);
      ierr = VecNorm(algebra->exactsolution,NORM_INFINITY,&norm);CHKERRQ(ierr);
      ierr = PetscPrintf(PETSC_COMM_WORLD,"Error: ||u_k-u|| = %g \n", norm);CHKERRQ(ierr);

      ierr = OutputVTK(user->dm, "Error.vtk", &viewer);CHKERRQ(ierr);
      ierr = VecView(algebra->exactsolution, viewer);CHKERRQ(ierr);
      ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
    }

    ierr = VecDestroy(&algebra->solution);CHKERRQ(ierr);
    ierr = VecDestroy(&algebra->f);CHKERRQ(ierr);
    ierr = VecDestroy(&algebra->oldsolution);CHKERRQ(ierr);
    ierr = VecDestroy(&algebra->fn);CHKERRQ(ierr);
    ierr = VecDestroy(&algebra->oldfn);CHKERRQ(ierr);

    ierr = SNESDestroy(&user->snes);CHKERRQ(ierr);
    ierr = DMDestroy(&user->dm);CHKERRQ(ierr);

  } else {
    SETERRQ(PETSC_COMM_SELF,PETSC_ERR_USER,"WRONG option for the time integral method. Using the option '-time_integral_method 0 or 1'");
  }

  ierr = VecDestroy(&user->cellgeom);CHKERRQ(ierr);
  ierr = VecDestroy(&user->facegeom);CHKERRQ(ierr);
  ierr = DMDestroy(&user->dmGrad);CHKERRQ(ierr);

  ierr = PetscFunctionListDestroy(&LimitList);CHKERRQ(ierr);
  ierr = PetscFree(user->model->physics);CHKERRQ(ierr);
  ierr = PetscFree(user->algebra);CHKERRQ(ierr);
  ierr = PetscFree(user->model);CHKERRQ(ierr);
  ierr = PetscFree(user);CHKERRQ(ierr);

  {
    PetscLogDouble    space =0;
    ierr =  PetscMallocGetCurrentUsage(&space);CHKERRQ(ierr);
    ierr =  PetscPrintf(PETSC_COMM_WORLD,"Unfreed space at the End %g M\n", space/(1024*1024));CHKERRQ(ierr);
  }

  ierr = PetscFinalize();
  return(0);
}

//static const struct FieldDescription PhysicsFields_Partial[] = {{"Density",1},{"Momentum",DIM},{NULL,0}};
//static const struct FieldDescription PhysicsFields_Full[] = {{"Density",1},{"Momentum",DIM},{"Energy",1},{NULL,0}};

/*
Note that, in the compressible NS equations, we need a so called the equation of state, such as:
Acoustics sound waves: p = c^2 \rho, where p is the pressure, c is the speed of the sound, and \rho is the density
Ideal Gas Dynamics: p = (\gamma - 1)(E - 0.5\rho U \cdot U), where \gamma is the adiabatic index, E is the energy, and U is the velocity
Ideal Gas Dynamics: p = \alpha \rho^k
So we do not need put the pressure into the fields. See "http://en.wikipedia.org/wiki/Euler_equations_%28fluid_dynamics%29"
and "http://educ.jmu.edu/~sochacjs/compressible" for details.
*/

#undef __FUNCT__
#define __FUNCT__ "LoadOptions"
PetscErrorCode LoadOptions(MPI_Comm comm, User user)
{
  PetscErrorCode ierr;
  PetscBool         set = PETSC_FALSE;

  PetscFunctionBeginUser;

  Model     model = user->model;
  //Algebra   algebra = user->algebra;
  Physics   phy = model->physics;

  ierr = PetscOptionsBegin(comm,NULL,"Physics Model Options","");CHKERRQ(ierr);
  {
    user->includeenergy = PETSC_FALSE;
    ierr = PetscOptionsBool("-includeenergy","Including the Energy fields","",user->includeenergy,&user->includeenergy,NULL);CHKERRQ(ierr);
    if (user->includeenergy){
      phy->field_desc = PhysicsFields_Full;
    }else{
      phy->field_desc = PhysicsFields_Partial;
    }
    user->KDof = 3.0;
    user->adiabatic = 1.67;
    //user->R = 8.3144621;
    user->R = 287.0;
    user->viscosity = 0.1;
    user->k = 0.026;
    user->inflow_u = 0.0;
    user->inflow_v = 0.0;
    user->inflow_w = 0.0;
    ierr = PetscOptionsReal("-kinematic_dof","Kinematic Degrees of freedom, for the monoatomic gas, kinematic_dof = 3 and for a diatomic gas, kinematic_dof = 5","",user->KDof,&user->KDof,NULL);CHKERRQ(ierr);
    ierr = PetscOptionsReal("-adiabatic","Heat capacity ratio or called adiabatic","", user->adiabatic, &user->adiabatic, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsReal("-R","The gas constant which is 8.3144621 J K^{-1} mol^{-1} for the state equation","", user->R, &user->R, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsReal("-viscosity","The viscosity of the flow","", user->viscosity, &user->viscosity, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsReal("-k","the thermal conductivity coefficient","", user->k, &user->k, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsReal("-inflow_u","the inflow velocity in x direction","", user->inflow_u, &user->inflow_u, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsReal("-inflow_v","the inflow velocity in y direction","", user->inflow_v, &user->inflow_v, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsReal("-inflow_w","the inflow velocity in z direction","", user->inflow_w, &user->inflow_w, NULL);CHKERRQ(ierr);
  }
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  ierr = PetscOptionsBegin(comm,NULL,"Unstructured Finite Volume Mesh Options","");CHKERRQ(ierr);
  {
    //user->filename = "sevenside.exo";
    ierr = PetscOptionsString("-f","Exodus.II filename to read","",user->filename,user->filename,sizeof(user->filename),NULL);CHKERRQ(ierr);
    user->show_partition = PETSC_FALSE;
    ierr = PetscOptionsBool("-show_partition","Write cell geometry (for debugging)","",user->show_partition,&user->show_partition,NULL);CHKERRQ(ierr);
    user->overlap = 1;
    ierr = PetscOptionsInt("-overlap","Number of cells to overlap partitions","",user->overlap,&user->overlap,NULL);CHKERRQ(ierr);
  }
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  ierr = PetscOptionsBegin(comm,NULL,"Unstructured Finite Volume Method Options","");CHKERRQ(ierr);
  {
    user->reconstruct = PETSC_FALSE;
    ierr = PetscOptionsBool("-reconstruct","Reconstruct gradients for a second order method (grows stencil)","",user->reconstruct,&user->reconstruct,NULL);CHKERRQ(ierr);
    user->TimeIntegralMethod = 0;
    ierr = PetscOptionsInt("-time_integral_method","Method for the time integral, 0 for the explicit method and 1 for the implicit method","",user->TimeIntegralMethod,&user->TimeIntegralMethod,NULL);CHKERRQ(ierr);
    user->timestep = 0;
    ierr = PetscOptionsInt("-timestep","Scheme for the implicit time integral: backward Euler, BDF2, ...","",user->timestep,&user->timestep,NULL);CHKERRQ(ierr);
    user->myownexplicitmethod = PETSC_FALSE;
    ierr = PetscOptionsBool("-myownexplicitmethod","Using my own explicit metod","",user->myownexplicitmethod,&user->myownexplicitmethod,NULL);CHKERRQ(ierr);
    user->PressureFlux = PETSC_FALSE;
    ierr = PetscOptionsBool("-PressureFlux","Transfer the pressure term to the flux style","",user->PressureFlux,&user->PressureFlux,NULL);CHKERRQ(ierr);

    user->output_solution = PETSC_FALSE;
    ierr = PetscOptionsBool("-output_solution","output the solution to a file","",user->output_solution,&user->output_solution,NULL);CHKERRQ(ierr);

    if(user->output_solution){
    // the output file options
      ierr = PetscOptionsString("-solutionfile", "solution file", "AeroSim.c", user->solutionfile,user->solutionfile, 2048, &set);CHKERRQ(ierr);
      if(!set){SETERRQ(PETSC_COMM_SELF, PETSC_ERR_ARG_NULL,"please use option -solutionfile to specify solution file name \n");}
      ierr = PetscOptionsInt("-steps_output", "the number of time steps between two outputs", "", user->steps_output, &user->steps_output, &set);CHKERRQ(ierr);
      if(!set){ user->steps_output = 1;}
    }

    user->JdiffP = PETSC_FALSE;
    ierr = PetscOptionsBool("-JdiffP","The preconditioner matrix is different from the Jacobian matrix","",user->JdiffP,&user->JdiffP,NULL);CHKERRQ(ierr);
    user->dt = 0.001;
    ierr = PetscOptionsReal("-dt","The time step size","",user->dt,&user->dt,NULL);CHKERRQ(ierr);
    user->initial_time = 0.0;
    ierr = PetscOptionsReal("-initial_time","The initial time","", user->initial_time, &user->initial_time, NULL);CHKERRQ(ierr);
    user->final_time = 1.0;
    ierr = PetscOptionsReal("-final_time","The final time","",user->final_time,&user->final_time,NULL);CHKERRQ(ierr);

    user->second_order = PETSC_FALSE;
    ierr = PetscOptionsBool("-second_order","Use the second order scheme by using the reconstruction","",user->second_order,&user->second_order,NULL);CHKERRQ(ierr);
    user->fd_jacobian = PETSC_FALSE;
    ierr = PetscOptionsBool("-fd_jacobian","Use the PETSc default finite difference method to construct the Jacobian matrix","",user->fd_jacobian,&user->fd_jacobian,NULL);CHKERRQ(ierr);
    user->fd_jacobian_color = PETSC_FALSE;
    ierr = PetscOptionsBool("-fd_jacobian_color","Use the PETSc default finite difference method to construct the Jacobian matrix","",user->fd_jacobian_color,&user->fd_jacobian_color,NULL);CHKERRQ(ierr);

  }
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  ierr = PetscOptionsBegin(comm,NULL,"Other Options","");CHKERRQ(ierr);
  {
    user->benchmark_couette = PETSC_FALSE;
    ierr = PetscOptionsBool("-benchmark_couette","For the Couette benchmark problem test","",user->benchmark_couette,&user->benchmark_couette,NULL);CHKERRQ(ierr);
    user->max_time_its = 0;
    ierr = PetscOptionsInt("-max_time_its","The maximum time steps","",user->max_time_its,&user->max_time_its,NULL);CHKERRQ(ierr);
    user->Explicit_RK2 = PETSC_FALSE;
    ierr = PetscOptionsBool("-Explicit_RK2","Use the second order Runge Kutta method","",user->Explicit_RK2,&user->Explicit_RK2,NULL);CHKERRQ(ierr);
    user->Explicit_RK4 = PETSC_FALSE;
    ierr = PetscOptionsBool("-Explicit_RK4","Use the second order Runge Kutta method","",user->Explicit_RK4,&user->Explicit_RK4,NULL);CHKERRQ(ierr);

    user->T0 = 0.0;
    ierr = PetscOptionsReal("-T0","For the couette test case","", user->T0, &user->T0, NULL);CHKERRQ(ierr);
    user->T1 = 0.0;
    ierr = PetscOptionsReal("-T1","For the couette test case","", user->T1, &user->T1, NULL);CHKERRQ(ierr);

    user->Euler = PETSC_FALSE;
    ierr = PetscOptionsBool("-Euler","Use the Euler equation","",user->Euler,&user->Euler, NULL);CHKERRQ(ierr);

  }
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SolveSteadyState"
/**
   Solves the steady-state problem, with d/dt terms 0.  How well this works is
   debatable - for structure-only problems it works, but for fluid
   I'm doubtful.

   @param ctx my application context
*/
PetscErrorCode SolveSteadyState(void* ctx)
{
  User                 user = (User)ctx;
  Algebra              algebra = user->algebra;
  PetscMPIInt          rank, size;
  PetscErrorCode       ierr;

  PetscLogDouble       v1, v2;
  SNESConvergedReason  snesreason;

  PetscFunctionBegin;

  ierr = MPI_Comm_rank(PETSC_COMM_WORLD,&rank);CHKERRQ(ierr);
  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRQ(ierr);

  ierr = PetscPrintf(PETSC_COMM_WORLD,"Solving steady-state problem\n");CHKERRQ(ierr);

  ierr = SNESMonitorSet(user->snes, MonitorFunction, (void*) user,
			PETSC_NULL);CHKERRQ(ierr);

  ierr = PetscTime(&v1);CHKERRQ(ierr);

  /* solving */
  ierr = SNESSolve(user->snes, PETSC_NULL, algebra->solution);CHKERRQ(ierr);
//  Vec func;
//  ierr = SNESGetFunction(user->snes,&func,0,0);CHKERRQ(ierr);
//  VecView(func,PETSC_VIEWER_STDOUT_WORLD);

  ierr = SNESGetConvergedReason(user->snes,&snesreason);CHKERRQ(ierr);
  ierr = PetscTime(&v2);CHKERRQ(ierr);

  if (snesreason > -1) {
    ierr = PetscPrintf(PETSC_COMM_WORLD,
		       "Solution time of %f sec, SNES converged %d (%s) \n",
		       v2 - v1, snesreason, SNESConvergedReasons[snesreason]);CHKERRQ(ierr);
  } else {
    ierr = PetscPrintf(PETSC_COMM_WORLD,
		       "Solution time of %f sec, SNES diverged %d (%s).\n",
		       v2 - v1, snesreason, SNESConvergedReasons[snesreason]);CHKERRQ(ierr);
  }

  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SolveTimeDependent"
/**
   In theory we have SolveTimeDependent and SolveSteadyState, the latter doesn't work very well.

   @param ctx the application context
*/
PetscErrorCode SolveTimeDependent(void* ctx)
{
  User                 user = (User)ctx;
  PetscMPIInt          rank, size;
  PetscErrorCode       ierr;

  Algebra              algebra = user->algebra;

  PetscLogDouble v1, v2;
  SNESConvergedReason snesreason;

  PetscFunctionBegin;

  ierr = MPI_Comm_rank(PETSC_COMM_WORLD,&rank);CHKERRQ(ierr);
  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRQ(ierr);

  /* set current time and step */
  user->current_time = user->initial_time;
  user->current_step = 1;
  ierr = SNESMonitorSet(user->snes, MonitorFunction, (void*) user,
			PETSC_NULL);CHKERRQ(ierr);

  /* start the time step iteration */
  while (user->current_time < (user->final_time - 0.05 * user->dt)) {
    /*Do a simple adaptive time step size*/

    ierr = VecCopy(algebra->solution, algebra->oldsolution);CHKERRQ(ierr);
    ierr = VecCopy(algebra->fn, algebra->oldfn);CHKERRQ(ierr);

    /* b) update the current time */
    user->current_time += user->dt;

    ierr = PetscPrintf(PETSC_COMM_WORLD,"\nCurrent time = %f\n",
		         user->current_time); CHKERRQ(ierr);

    /* c) solve the time dependent problem */
    ierr = PetscTime(&v1);CHKERRQ(ierr);
    ierr = SNESSolve(user->snes, PETSC_NULL, algebra->solution);CHKERRQ(ierr);
    ierr = PetscTime(&v2);CHKERRQ(ierr);

    ierr = SNESGetConvergedReason(user->snes,&snesreason);CHKERRQ(ierr);
    if (snesreason > -1) {
      ierr = PetscPrintf(PETSC_COMM_WORLD,
		       "Solution time of %f sec, SNES converged %d (%s) \n",
		       v2 - v1, snesreason, SNESConvergedReasons[snesreason]);CHKERRQ(ierr);
    } else {
      ierr = PetscPrintf(PETSC_COMM_WORLD,
		       "Solution time of %f sec, SNES diverged %d (%s).\n",
		       v2 - v1, snesreason, SNESConvergedReasons[snesreason]);CHKERRQ(ierr);
    }

    user->current_step++;

  }/* end while*/
  PetscFunctionReturn(0);
}


#undef __FUNCT__
#define __FUNCT__ "SetInitialCondition"
PetscErrorCode SetInitialCondition(DM dm, Vec X, User user)
{
  DM                dmCell;
  const PetscScalar *cellgeom;
  PetscScalar       *x;
  PetscInt          cStart, cEnd, cEndInterior = user->cEndInterior, c;
  PetscErrorCode    ierr;

  PetscFunctionBeginUser;
  ierr = VecGetDM(user->cellgeom, &dmCell);CHKERRQ(ierr);
  ierr = DMPlexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->cellgeom, &cellgeom);CHKERRQ(ierr);
  ierr = VecGetArray(X, &x);CHKERRQ(ierr);
  for (c = cStart; c < cEndInterior; ++c) {
    const CellGeom *cg;
    PetscScalar    *xc;

    ierr = DMPlexPointLocalRead(dmCell,c,cellgeom,&cg);CHKERRQ(ierr);
    ierr = DMPlexPointGlobalRef(dm,c,x,&xc);CHKERRQ(ierr);
    if (xc) {
      ierr = InitialCondition(0.0, cg->centroid, xc, user);CHKERRQ(ierr);
    }
  }
  ierr = VecRestoreArrayRead(user->cellgeom, &cellgeom);CHKERRQ(ierr);
  ierr = VecRestoreArray(X, &x);CHKERRQ(ierr);

  { //Apply the Boundary condition for the intial condition
    Vec             XLocal;
    ierr = DMGetLocalVector(user->dm, &XLocal);CHKERRQ(ierr);
    ierr = VecSet(XLocal, 0);CHKERRQ(ierr);

    ierr = DMGlobalToLocalBegin(user->dm, X, INSERT_VALUES, XLocal);CHKERRQ(ierr);
    ierr = DMGlobalToLocalEnd(user->dm, X, INSERT_VALUES, XLocal);CHKERRQ(ierr);
    ierr = ApplyBC(user->dm, user->current_time, XLocal, user);CHKERRQ(ierr);
    ierr = DMLocalToGlobalBegin(user->dm, XLocal, INSERT_VALUES, X);CHKERRQ(ierr);
    ierr = DMLocalToGlobalEnd(user->dm, XLocal, INSERT_VALUES, X);CHKERRQ(ierr);
  }

  PetscFunctionReturn(0);
}


#undef __FUNCT__
#define __FUNCT__ "OutputVTK"
PetscErrorCode OutputVTK(DM dm, const char *filename, PetscViewer *viewer)
{
  PetscErrorCode ierr;

  PetscFunctionBeginUser;
  ierr = PetscViewerCreate(PetscObjectComm((PetscObject)dm), viewer);CHKERRQ(ierr);
  ierr = PetscViewerSetType(*viewer, PETSCVIEWERVTK);CHKERRQ(ierr);
  ierr = PetscViewerFileSetName(*viewer, filename);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "MonitorFunction"
/**
   My handrolled SNES monitor.  Gives some information about KSP convergence as well
   as looking pretty.

   @param snes Petsc nonlinear context
   @param its number of iterations
   @param norm norm of nonlinear residual
   @param dctx application context
*/
PetscErrorCode MonitorFunction(SNES snes, PetscInt its, double norm, void *dctx)
{
  PetscErrorCode ierr;
  PetscInt lits;
  PetscMPIInt rank;
  KSP ksp;
  KSPConvergedReason kspreason;
  PetscReal kspnorm;

  PetscFunctionBegin;
  ierr = MPI_Comm_rank(PETSC_COMM_WORLD,&rank);CHKERRQ(ierr);

  ierr = SNESGetKSP(snes, &ksp);CHKERRQ(ierr);
  ierr = KSPGetConvergedReason(ksp, &kspreason);CHKERRQ(ierr);
  ierr = KSPGetResidualNorm(ksp, &kspnorm);CHKERRQ(ierr);
  ierr = KSPGetIterationNumber(ksp, &lits);CHKERRQ(ierr);

  ierr = PetscPrintf(PETSC_COMM_WORLD, "  %d SNES norm %e, %d KSP its last norm %e",
		       its, norm, lits, kspnorm);CHKERRQ(ierr);
  if (kspreason < 0) {
      ierr = PetscPrintf(PETSC_COMM_WORLD, ", KSP failed: %s", KSPConvergedReasons[kspreason]);CHKERRQ(ierr);
  }

  ierr = PetscPrintf(PETSC_COMM_WORLD, ".\n");CHKERRQ(ierr);

  PetscFunctionReturn(0);
}
